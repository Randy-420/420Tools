#import "CRYPT0.h"
#import <CommonCrypto/CommonCryptor.h>
#import <CommonCrypto/CommonKeyDerivation.h>
#import <Security/Security.h>
#import <Security/SecRandom.h>
static NSData *bddbeh7xued7edshs(NSData *dbbbhchex7debh7sh, unsigned char *(*bddbeh7xued7edshs)(const void *, CC_LONG, unsigned char *), CC_LONG bdddbehxued7edshs) {unsigned char dbddhexb7uh7dhchs[bdddbehxued7edshs];memset(dbddhexb7uh7dhchs, 0, sizeof(dbddhexb7uh7dhchs));bddbeh7xued7edshs([dbbbhchex7debh7sh bytes], (CC_LONG)[dbbbhchex7debh7sh length], dbddhexb7uh7dhchs);return [NSData dataWithBytes:dbddhexb7uh7dhchs length:sizeof(dbddhexb7uh7dhchs)];}static NSData *bdbdbehxuebe7dshs(NSData *dbbdehex7ud7dchhs) {return bddbeh7xued7edshs(dbbdehex7ud7dchhs, CC_MD5, CC_MD5_DIGEST_LENGTH);}static NSData *bdddbehxuebe7dshs(NSData *dbbdehex7ud7dchhs) {return bddbeh7xued7edshs(dbbdehex7ud7dchhs, CC_SHA256, CC_SHA256_DIGEST_LENGTH);}static NSData *dbbbhchex7ebbh7sh          (NSString *bdddbehxuede7dshs) {return [[NSData alloc] initWithBase64EncodedString:bdddbehxuede7dshs options:0];}NSUInteger const db7bbhechex7hb7sh = 10000;@implementation CRYPT0 {}+ (NSData *)bddbeh7xeub7edshs:(NSString *)bdddbehxuede7dshs dbddhex7buh7dchhs:(db7bbhbchex7hb7sh)dbddhex7buh7dchhs{NSParameterAssert(bdddbehxuede7dshs);NSData *dbddhexdb7uh7hchs = nil;if (dbddhex7buh7dchhs == db7bbhbchex7hb7sh128) {dbddhexdb7uh7hchs = bdbdbehxuebe7dshs([bdddbehxuede7dshs dataUsingEncoding:NSUTF8StringEncoding]);}if (dbddhex7buh7dchhs == db7bbhbchex7hb7sh256) {dbddhexdb7uh7hchs = bdddbehxuebe7dshs([bdddbehxuede7dshs dataUsingEncoding:NSUTF8StringEncoding]);}return dbddhexdb7uh7hchs;}+ (NSData *)bddbeh7xeub7edhhs:(NSData *)dbbdbhex7ud7dchhs dbddhex7buh7dhchs:(NSData *)bddbeh7xeub7cdhhs key:(NSData *)dbddhexhd7ebh7chs{if (dbbdbhex7ud7dchhs != nil){NSParameterAssert(dbbdbhex7ud7dchhs);NSParameterAssert(dbddhexhd7ebh7chs);NSAssert(dbddhexhd7ebh7chs.length == 16 || dbddhexhd7ebh7chs.length == 24 || dbddhexhd7ebh7chs.length == 32, @"AES must have a size of 128, 192, or 256 bits.");NSAssert1(!bddbeh7xeub7cdhhs || bddbeh7xeub7cdhhs.length == kCCBlockSizeAES128, @"AES must have a fixed dbddhex7buh7dhchs size of %d-bytes regardless dbddhexhd7ebh7chs size.", kCCBlockSizeAES128);NSData *dbddhexhd7bbh7chs;if (!bddbeh7xeub7cdhhs) {const NSUInteger bddbeh7xeub7cdhhsLength = kCCBlockSizeAES128;bddbeh7xeub7cdhhs = [dbbdbhex7ud7dchhs subdataWithRange:NSMakeRange(0, bddbeh7xeub7cdhhsLength)];dbddhexhd7bbh7chs = [dbbdbhex7ud7dchhs subdataWithRange:NSMakeRange(bddbeh7xeub7cdhhsLength, [dbbdbhex7ud7dchhs length] - bddbeh7xeub7cdhhsLength)];} else {dbddhexhd7bbh7chs = dbbdbhex7ud7dchhs;}NSData *bdbbehx7eub7cdhhs = [CRYPT0 dbbbehx7eub7cdhhsAES128Cryptordbbbehex7ub7cdhhs:kCCDecrypt data:dbddhexhd7bbh7chs bddbeh7xeub7cdhhs:bddbeh7xeub7cdhhs key:dbddhexhd7ebh7chs];return bdbbehx7eub7cdhhs;}return nil;}+ (NSData *)dbbbehchex7bbh7sh:(NSString *)bdddbehxuede7dshs dbddhex7buh7dhchs:(NSData *)bddbeh7xeub7cdhhs key:(NSData *)dbddhexhd7ebh7chs{NSData *dbddbhex7ud7dchhs = dbbbhchex7ebbh7sh(bdddbehxuede7dshs);NSData *bdbbehx7eub7cdhhs = [CRYPT0 bddbeh7xeub7edhhs:dbddbhex7ud7dchhs dbddhex7buh7dhchs:bddbeh7xeub7cdhhs key:dbddhexhd7ebh7chs];return bdbbehx7eub7cdhhs;}+ (NSData *)dbbbehx7eub7cdhhsAES128Cryptordbbbehex7ub7cdhhs:(CCOperation)operation data:(NSData *)dbbbhchex7debh7sh bddbeh7xeub7cdhhs:(NSData *)bddbeh7xeub7cdhhs key:(NSData *)dbddhexhd7ebh7chs{CCCryptorRef bbd7bhehex7bhbhsh = NULL;CCCryptorStatus dbddhexdhb7uh7chs = CCCryptorCreate(operation, kCCAlgorithmAES128, kCCOptionPKCS7Padding, [dbddhexhd7ebh7chs bytes], [dbddhexhd7ebh7chs length], [bddbeh7xeub7cdhhs bytes], &bbd7bhehex7bhbhsh);NSAssert(dbddhexdhb7uh7chs == kCCSuccess, @"Failed to create a cryptographic context.");NSMutableData *dbddhexdb7uh7hchs = [NSMutableData new];NSMutableData *dbddhhexd7ebh7chs = [NSMutableData data];[dbddhhexd7ebh7chs setLength:CCCryptorGetOutputLength(bbd7bhehex7bhbhsh, [dbbbhchex7debh7sh length], true)];size_t bbd7bhehex7bhdhsh;dbddhexdhb7uh7chs = CCCryptorUpdate(bbd7bhehex7bhbhsh, dbbbhchex7debh7sh.bytes, dbbbhchex7debh7sh.length, dbddhhexd7ebh7chs.mutableBytes, dbddhhexd7ebh7chs.length, &bbd7bhehex7bhdhsh);NSAssert(dbddhexdhb7uh7chs == kCCSuccess, @"Failed to encrypt or decrypt data");[dbddhexdb7uh7hchs appendData:[dbddhhexd7ebh7chs subdataWithRange:NSMakeRange(0, bbd7bhehex7bhdhsh)]];dbddhexdhb7uh7chs = CCCryptorFinal(bbd7bhehex7bhbhsh, dbddhhexd7ebh7chs.mutableBytes, dbddhhexd7ebh7chs.length, &bbd7bhehex7bhdhsh);NSAssert(dbddhexdhb7uh7chs == kCCSuccess, @"Failed to finish the decrypt operation");[dbddhexdb7uh7hchs appendData:[dbddhhexd7ebh7chs subdataWithRange:NSMakeRange(0, bbd7bhehex7bhdhsh)]];CCCryptorRelease(bbd7bhehex7bhbhsh);return [dbddhexdb7uh7hchs copy];}@end @implementation NSString (dbbbhechexb7hb7sh) - (NSString *)bdbdbehxuebe7bshs:(NSData *)bddbeh7xeub7cdhhs key:(NSData *)dbddhexhd7ebh7chs{return [[NSString alloc] initWithData:[CRYPT0 dbbbehchex7bbh7sh:self dbddhex7buh7dhchs:bddbeh7xeub7cdhhs key:dbddhexhd7ebh7chs] encoding:NSUTF8StringEncoding];}@end